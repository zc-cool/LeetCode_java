/**
 * @author zhucheng
 * @create 2021-04-08-16:17
 */
package medium.array;
//给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
//
//
//
// 进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
//
//
//
// 示例 1：
//
//
//输入：nums = [1,2,1,3,2,5]
//输出：[3,5]
//解释：[5, 3] 也是有效的答案。
//
//
// 示例 2：
//
//
//输入：nums = [-1,0]
//输出：[-1,0]
//
//
// 示例 3：
//
//
//输入：nums = [0,1]
//输出：[1,0]
//
//
// 提示：
//
//
// 2 <= nums.length <= 3 * 104
// -231 <= nums[i] <= 231 - 1
// 除两个只出现一次的整数外，nums 中的其他数字都出现两次
//
// Related Topics 位运算
// 👍 386 👎 0

/*
    思路：
    现在数组中有两个数字只出现1次，直接异或一次只能得到这两个数字的异或结果，
    但光从这个结果肯定无法得到这个两个数字。
    因此基于single number I 的思路——数组只能有一个数字出现1次。
    设题目中这两个只出现1次的数字分别为A和B，如果能将A，B分开到二个数组中，
    那显然符合“异或”解法的关键点了。因此这个题目的关键点就是将A，B分开到二个数组中。
    由于A，B肯定是不相等的，因此在二进制上必定有一位是不同的。
    根据这一位是0还是1可以将A，B分开到A组和B组。而这个数组中其它数字要么就属于A组，
    要么就属于B组。再对A组和B组分别执行“异或”解法就可以得到A，B了。
    而要判断A，B在哪一位上不相同，只要根据A异或B的结果就可以知道了，
    这个结果在二进制上为1的位就说明A，B在这一位上是不相同的。

    比如
    int a[] = {1, 1, 3, 5, 2, 2}
    整个数组异或的结果为3^5，即 0x0011 ^ 0x0101 = 0x0110
    对0x0110，第1位（由低向高，从0开始）就是1。因此整个数组根据第1位是0还是1分成两组。
    a[0] =1  0x0001  第一组
    a[1] =1  0x0001  第一组
    a[2] =3  0x0011  第二组
    a[3] =5  0x0101  第一组
    a[4] =2  0x0010  第二组
    a[5] =2  0x0010  第二组
    第一组有{1,1,5}，第二组有{3,2,2}，然后对这二组分别执行“异或”解法就可以得到5和3了。
     */
public class NSingleNumber260 {
    public int[] singleNumber(int[] nums) {
        int[] array = new int[2];
        if (nums == null || nums.length < 2) {
            return array;
        }

        int tem = 0;
        for(int num : nums){
            tem = tem ^ num;  //tem是两个只出现一次的数异或结果。
        }

        int i = 0;
        while((tem & 1) == 0){
            i++;
            tem = tem >> 1;
        }
        tem = 1 << i;


        for(int e : nums){
            if((e & tem) == 0){
                array[0] ^= e;
            }else{
                array[1] ^= e;
            }
        }
        return array;
    }
}
