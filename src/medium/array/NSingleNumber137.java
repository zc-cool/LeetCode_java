/**
 * @author zhucheng
 * @create 2021-04-08-14:40
 */
package medium.array;
//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。
//
// 说明：
//
// 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
//
// 示例 1:
//
// 输入: [2,2,3,2]
//输出: 3
//
//
// 示例 2:
//
// 输入: [0,1,0,1,0,1,99]
//输出: 99
// Related Topics 位运算
// 👍 545 👎 0
public class NSingleNumber137 {
    class Solution {
        /*
        位运算：与&、或|、异或^、非~、左移<<、右移>>、无符号右移>>>
        例子：
        观察[9,10,9,10,9,10,13]
        1001
        1010
        1001
        1010
        1001
        1010
        1101
        每个位的1相加，然后%3.如果=0，说明该位不影响结果，如果=1.说明该位影响了结果
        （因为如果每个数字都出现3次，那么该位上的1加起来，肯定能被3除尽）。起始结果是0（每个位都是0），
        这样我们把0的对应该位置置为1。所有位都按这这种方式，则最终的0被我们改造的有的位上变成了1.
        最终这个‘0’就是我们要的那个只出现一次的数字（相当于用0来还原这个只出现一次数字的二进制位）

        假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 6
        1: 0 0 1
        2: 0 1 0
        6: 1 1 0
        1: 0 0 1
        1: 0 0 1
        2: 0 1 0
        2: 0 1 0
        3: 0 1 1
        3: 0 1 1
        3: 0 1 1
        看最右边的一列 1001100111 有 6 个 1
        再往前看一列 0110011111 有 7 个 1
        再往前看一列 0010000 有 1 个 1
        我们只需要把是 3 的倍数的对应列写 0，不是 3 的倍数的对应列写 1
        也就是 1 1 0,也就是 6。
        原因的话，其实很容易想明白。如果所有数字都出现了 3 次，那么每一列的 1 的个数就一定是 3 的倍数。
        之所以有的列不是 3 的倍数，就是因为只出现了 1 次的数贡献出了 1。所以所有不是 3 的倍数的列写 1，
        其他列写 0 ，就找到了这个出现 1 次的数。
         */
        public int singleNumber(int[] nums) {
            int ans = 0;
            for (int i = 0; i < 32; i++) {
                int count = 0;
                for(int num : nums){
                    if((num >>> i & 1) == 1){
                        count++;
                    }
                }
                if(count % 3 != 0)
                    ans = ans | 1 << i;
            }
            return ans;
        }
    }
}
